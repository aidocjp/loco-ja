+++
title = "Locoã‚¬ã‚¤ãƒ‰"
date = 2021-05-01T08:00:00+00:00
updated = 2021-05-01T08:00:00+00:00
draft = false
weight = 3
sort_by = "weight"
template = "docs/page.html"

[extra]
toc = true
top = false
flair =[]
+++

## ã‚¬ã‚¤ãƒ‰ã®å‰ææ¡ä»¶

ã“ã‚Œã¯ã€Œé•·ã„é“ã®ã‚Šã€ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã™ã€‚æ„å›³çš„ã«é•·ãè©³ç´°ã«ã—ã¦ãŠã‚Šã€æ‰‹å‹•ã§ã®ãƒ“ãƒ«ãƒ‰æ–¹æ³•**ã¨**ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ã£ãŸè‡ªå‹•ãƒ“ãƒ«ãƒ‰æ–¹æ³•ã®ä¸¡æ–¹ã‚’å­¦ç¿’ã§ãã‚‹ã‚ˆã†ã«ã€æ§‹ç¯‰ã‚¹ã‚­ãƒ«ã¨ä»•çµ„ã¿ã®ç†è§£ã®ä¸¡æ–¹ã‚’èº«ã«ã¤ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚


### åå‰ã®ç”±æ¥ã¯ï¼Ÿ

`Loco`ã¨ã„ã†åå‰ã¯**loco**motiveã‹ã‚‰æ¥ã¦ãŠã‚Šã€Railsã¸ã®æ•¬æ„ã‚’è¡¨ã—ãŸã‚‚ã®ã§ã€`loco`ã®æ–¹ãŒ`locomotive`ã‚ˆã‚Šå…¥åŠ›ã—ã‚„ã™ã„ã‹ã‚‰ã§ã™ :-) ã¾ãŸã€ã„ãã¤ã‹ã®è¨€èªã§ã¯ã€Œã‚¯ãƒ¬ã‚¤ã‚¸ãƒ¼ã€ã‚’æ„å‘³ã—ã¾ã™ãŒã€ãã‚Œã¯æœ¬æ¥ã®æ„å›³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚ã‚‹ã„ã¯ã€Rustã§Railsã‚’æ§‹ç¯‰ã™ã‚‹ã®ã¯ã‚¯ãƒ¬ã‚¤ã‚¸ãƒ¼ãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿæ™‚ãŒæ•™ãˆã¦ãã‚Œã‚‹ã§ã—ã‚‡ã†ï¼ï¼‰ã€‚

### ã©ã®ç¨‹åº¦ã®Rustã®çŸ¥è­˜ãŒå¿…è¦ã§ã™ã‹ï¼Ÿ

åˆå¿ƒè€…ãƒ¬ãƒ™ãƒ«ã®Rustã«ç²¾é€šã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ä¸­ç´šåˆå¿ƒè€…ãƒ¬ãƒ™ãƒ«ä»¥ä¸Šã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚Rustãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ“ãƒ«ãƒ‰ã€ãƒ†ã‚¹ãƒˆã€å®Ÿè¡Œæ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã¦ã€`clap`ã€`regex`ã€`tokio`ã€`axum`ãªã©ã®äººæ°—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ãã®ä»–ã®Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ã£ãŸã“ã¨ãŒã‚ã‚‹ç¨‹åº¦ã§ååˆ†ã§ã™ã€‚ç‰¹ã«é«˜åº¦ãªã‚‚ã®ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚Locoã«ã¯ã€å‹•ä½œåŸç†ã‚’ç†è§£ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚ˆã†ãªè¤‡é›‘ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚„ã‚ã¾ã‚Šã«ã‚‚é­”æ³•çš„ãªãƒã‚¯ãƒ­ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚


### Locoã¨ã¯ï¼Ÿ

Locoã¯Railsã«å¼·ãã‚¤ãƒ³ã‚¹ãƒ‘ã‚¤ã‚¢ã•ã‚Œã¦ã„ã¾ã™ã€‚Railsã¨Rustã®ä¸¡æ–¹ã‚’çŸ¥ã£ã¦ã„ã‚Œã°ã€é¦´æŸ“ã¿ã‚„ã™ãæ„Ÿã˜ã‚‹ã§ã—ã‚‡ã†ã€‚Railsã—ã‹çŸ¥ã‚‰ãªãã¦RustãŒåˆã‚ã¦ã®å ´åˆã€Locoã‚’æ–°é®®ã«æ„Ÿã˜ã‚‹ã§ã—ã‚‡ã†ã€‚Railsã®çŸ¥è­˜ã¯å‰æã¨ã—ã¦ã„ã¾ã›ã‚“ã€‚

<div class="infobox">
Railsã¯ã¨ã¦ã‚‚ç´ æ™´ã‚‰ã—ã„ã®ã§ã€ã“ã®ã‚¬ã‚¤ãƒ‰ã‚‚<a href="https://guides.rubyonrails.org/getting_started.html">Railsã‚¬ã‚¤ãƒ‰</a>ã«å¼·ãã‚¤ãƒ³ã‚¹ãƒ‘ã‚¤ã‚¢ã•ã‚Œã¦ã„ã¾ã™
</div>

Locoã¯Rustå‘ã‘ã®Webã¾ãŸã¯APIãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚ã¾ãŸã€é–‹ç™ºè€…å‘ã‘ã®ç”Ÿç”£æ€§ã‚¹ã‚¤ãƒ¼ãƒˆã§ã‚‚ã‚ã‚Šã¾ã™ï¼šè¶£å‘³ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚„æ¬¡ã®ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã‚’æ§‹ç¯‰ã™ã‚‹éš›ã«å¿…è¦ãªã‚‚ã®ãŒã™ã¹ã¦å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚Railsã«å¼·ãã‚¤ãƒ³ã‚¹ãƒ‘ã‚¤ã‚¢ã•ã‚Œã¦ã„ã¾ã™ã€‚

- **MVCãƒ¢ãƒ‡ãƒ«ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³**ã«ã‚ˆã‚Šã€é¸æŠè‚¢ã®ãƒ‘ãƒ©ãƒ‰ãƒƒã‚¯ã‚¹ã‚’æ’é™¤ã—ã¾ã™ã€‚ã‚¢ãƒ—ãƒªã®æ§‹ç¯‰ã«é›†ä¸­ã§ãã€ã©ã®æŠ½è±¡åŒ–ã‚’ä½¿ã†ã‹ã¨ã„ã£ãŸå­¦è¡“çš„ãªæ±ºå®šã‚’è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
- **ãƒ•ã‚¡ãƒƒãƒˆãƒ¢ãƒ‡ãƒ«ã€ã‚¹ãƒªãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼**ã€‚ãƒ¢ãƒ‡ãƒ«ã«ã¯ãƒ­ã‚¸ãƒƒã‚¯ã¨ãƒ“ã‚¸ãƒã‚¹å®Ÿè£…ã®å¤§éƒ¨åˆ†ã‚’å«ã¿ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã¯HTTPã‚’ç†è§£ã—ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’ç§»å‹•ã•ã›ã‚‹è»½é‡ãƒ«ãƒ¼ã‚¿ãƒ¼ã«ç•™ã‚ã‚‹ã¹ãã§ã™ã€‚
- **ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³é§†å‹•**ã«ã‚ˆã‚Šã€å‹¢ã„ã¨ãƒ•ãƒ­ãƒ¼ã‚’ç¶­æŒã—ã¾ã™ã€‚ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆã‚„ã‚¼ãƒ­ã‹ã‚‰ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ˆã‚Šã‚‚ã€ç”Ÿæˆæ©Ÿèƒ½ã‚’æ´»ç”¨ã—ã¾ã™ã€‚
- **ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒã€Œã‚¤ãƒ³ãƒ•ãƒ©å¯¾å¿œã€**ã€ã‚³ãƒ¼ãƒ‰ã‚’ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã—ã¦é…ç·šã™ã‚‹ã ã‘ã§ã™ï¼šã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã€ãƒ¢ãƒ‡ãƒ«ã€ãƒ“ãƒ¥ãƒ¼ã€ã‚¿ã‚¹ã‚¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–ã€ãƒ¡ãƒ¼ãƒ©ãƒ¼ãªã©ã€‚
- **è¨­å®šã‚ˆã‚Šè¦ç´„**ï¼šæ±ºå®šã¯ã™ã§ã«è¡Œã‚ã‚Œã¦ã„ã¾ã™ -- ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼æ§‹é€ ã€è¨­å®šã®å½¢å¼ã¨å€¤ã€ã‚¢ãƒ—ãƒªã®é…ç·šæ–¹æ³•ãŒã‚¢ãƒ—ãƒªã®å‹•ä½œã¨æœ€ã‚‚åŠ¹æœçš„ãªé–‹ç™ºæ–¹æ³•ã«å½±éŸ¿ã—ã¾ã™ã€‚

## æ–°ã—ã„Locoã‚¢ãƒ—ãƒªã®ä½œæˆ

ã“ã®ã‚¬ã‚¤ãƒ‰ã«å¾“ã£ã¦ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—ã®ã€Œãƒœãƒˆãƒ ã‚¢ãƒƒãƒ—ã€å­¦ç¿’ã‚’è¡Œã†ã‹ã€ã‚ˆã‚Šæ—©ã„ã€Œãƒˆãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã€ã®ç´¹ä»‹ã¨ã—ã¦[ãƒ„ã‚¢ãƒ¼](@/docs/getting-started/tour/index.md)ã«é€²ã‚€ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

<!-- <snip id="quick-installation-command" inject_from="yaml" template="sh"> -->
```sh
cargo install loco
cargo install sea-orm-cli # DBãŒå¿…è¦ãªå ´åˆã®ã¿
```
<!-- </snip> -->


### æ–°ã—ã„Locoã‚¢ãƒ—ãƒªã®ä½œæˆ

ã“ã‚Œã§æ–°ã—ã„ã‚¢ãƒ—ãƒªã‚’ä½œæˆã§ãã¾ã™ï¼ˆçµ„ã¿è¾¼ã¿èªè¨¼ã®ãŸã‚ã«ã€ŒSaaS appã€ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼‰ã€‚

<!-- <snip id="loco-cli-new-from-template" inject_from="yaml" template="sh"> -->
```sh
â¯ loco new
âœ” â¯ App name? Â· myapp
âœ” â¯ What would you like to build? Â· Saas App with client side rendering
âœ” â¯ Select a DB Provider Â· Sqlite
âœ” â¯ Select your background worker type Â· Async (in-process tokio async tasks)

ğŸš‚ Loco app generated successfully in:
myapp/

- assets: You've selected `clientside` for your asset serving configuration.

Next step, build your frontend:
  $ cd frontend/
  $ npm install && npm run build
```
<!-- </snip> -->



LocoãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ä½œæˆã™ã‚‹ã‚‚ã®ä¸€è¦§ï¼š

| ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ•ã‚©ãƒ«ãƒ€ | ç›®çš„                                                                                                                                                           |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src/`         | ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã€ãƒ¢ãƒ‡ãƒ«ã€ãƒ“ãƒ¥ãƒ¼ã€ã‚¿ã‚¹ã‚¯ãªã©ãŒå«ã¾ã‚Œã¦ã„ã¾ã™                                                                                                               |
| `app.rs`       | ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç™»éŒ²ãƒã‚¤ãƒ³ãƒˆã€‚é‡è¦ãªéƒ¨åˆ†ã‚’ã“ã“ã§é…ç·šã—ã¾ã™ã€‚                                                                                                  |
| `lib.rs`       | ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ§˜ã€…ãªRustå›ºæœ‰ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã€‚                                                                                                                 |
| `bin/`         | `main.rs`ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã™ã€ã“ã‚Œã«ã¤ã„ã¦å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“                                                                                                         |
| `controllers/` | ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒå«ã¾ã‚Œã€ã™ã¹ã¦ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã¯`mod.rs`çµŒç”±ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™                                                                                                   |
| `models/`      | ãƒ¢ãƒ‡ãƒ«ãŒå«ã¾ã‚Œã€`models/_entities`ã«ã¯è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸSeaORMãƒ¢ãƒ‡ãƒ«ã€`models/*.rs`ã«ã¯ãƒ¢ãƒ‡ãƒ«æ‹¡å¼µãƒ­ã‚¸ãƒƒã‚¯ãŒå«ã¾ã‚Œã€`mod.rs`çµŒç”±ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ |
| `views/`       | JSONãƒ™ãƒ¼ã‚¹ã®ãƒ“ãƒ¥ãƒ¼ã€‚APIçµŒç”±ã§JSONã¨ã—ã¦`serde`ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦å‡ºåŠ›ã§ãã‚‹æ§‹é€ ä½“ã€‚                                                                          |
| `workers/`     | ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚                                                                                                                                      |
| `mailers/`     | ãƒ¡ãƒ¼ãƒ«é€ä¿¡ç”¨ã®ãƒ¡ãƒ¼ãƒ©ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯ã¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã€‚                                                                                                                   |
| `fixtures/`    | ãƒ‡ãƒ¼ã‚¿ã¨è‡ªå‹•ãƒ•ã‚£ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿ãƒ­ã‚¸ãƒƒã‚¯ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚                                                                                                                |
| `tasks/`       | ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã€ãƒ“ã‚¸ãƒã‚¹ãƒ¬ãƒãƒ¼ãƒˆä½œæˆã€DB ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãªã©ã®æ—¥å¸¸çš„ãªãƒ“ã‚¸ãƒã‚¹æŒ‡å‘ã‚¿ã‚¹ã‚¯ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚                                         |
| `tests/`       | ã‚¢ãƒ—ãƒªå…¨ä½“ã®ãƒ†ã‚¹ãƒˆï¼šãƒ¢ãƒ‡ãƒ«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãªã©ã€‚                                                                                                                       |
| `config/`      | ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ™ãƒ¼ã‚¹ã®è¨­å®šãƒ•ã‚©ãƒ«ãƒ€ï¼šdevelopmentã€testã€production                                                                                                 |

## Hello, Loco!

ã„ãã¤ã‹ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç´ æ—©ãå–å¾—ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãã®ãŸã‚ã«ã¯ã€ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

`myapp`ã«ç§»å‹•ã§ãã¾ã™ï¼š

```sh
$ cd myapp
```

### ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•

<!-- <snip id="starting-the-server-command" inject_from="yaml" template="sh"> -->
```sh
cargo loco start
```
<!-- </snip> -->

ãã—ã¦ã€å‹•ä½œã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ï¼š

```sh
$ curl localhost:5150/_ping
{"ok":true}
```

çµ„ã¿è¾¼ã¿ã®`_ping`ãƒ«ãƒ¼ãƒˆã¯ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µãƒ¼ã«ã™ã¹ã¦ãŒæ­£å¸¸ã§ã‚ã‚‹ã“ã¨ã‚’çŸ¥ã‚‰ã›ã¾ã™ã€‚

å¿…è¦ãªã‚µãƒ¼ãƒ“ã‚¹ãŒã™ã¹ã¦ç¨¼åƒã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ï¼š

```sh
$ curl localhost:5150/_health
{"ok":true}
```

<div class="infobox">
çµ„ã¿è¾¼ã¿ã®<code>_health</code>ãƒ«ãƒ¼ãƒˆã¯ã€ã‚¢ãƒ—ãƒªãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ï¼šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨Redisã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®æ¥ç¶šã‚’æ­£å¸¸ã«ç¢ºç«‹ã§ãã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚
</div>

### "Hello", Loco

ã‚µãƒ¼ãƒ“ã‚¹ã«ç´ æ—©ã„_hello_ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿½åŠ ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```sh
$ cargo loco generate controller guide --api
added: "src/controllers/guide.rs"
injected: "src/controllers/mod.rs"
injected: "src/app.rs"
added: "tests/requests/guide.rs"
injected: "tests/requests/mod.rs"
```

This is the generated controller body:

```rust
#![allow(clippy::missing_errors_doc)]
#![allow(clippy::unnecessary_struct_initialization)]
#![allow(clippy::unused_async)]
use loco_rs::prelude::*;
use axum::debug_handler;

#[debug_handler]
pub async fn index(State(_ctx): State<AppContext>) -> Result<Response> {
    format::empty()
}

pub fn routes() -> Routes {
    Routes::new()
        .prefix("api/guides/")
        .add("/", get(index))
}
```


Change the `index` handler body:

```rust
// replace
    format::empty()
// with this
    format::text("hello")
```

Start the server:

<!-- <snip id="starting-the-server-command" inject_from="yaml" template="sh"> -->
```sh
cargo loco start
```
<!-- </snip> -->

Now, let's test it out:

```sh
$ curl localhost:5150/api/guides
hello
```

Loco has powerful generators, which will make you 10x productive and drive your momentum when building apps.

If you'd like to be entertained for a moment, let's "learn the hard way" and add a new controller manually as well.

Add a file called `home.rs`, and line `pub mod home;` in `mod.rs`:

```
src/
  controllers/
    auth.rs
    home.rs      <--- add this file
    users.rs
    mod.rs       <--- 'pub mod home;' the module here
```

Next, set up a _hello_ route, this is the contents of `home.rs`:

```rust
// src/controllers/home.rs
use loco_rs::prelude::*;

// _ctx contains your database connection, as well as other app resource that you'll need
async fn hello(State(_ctx): State<AppContext>) -> Result<Response> {
    format::text("ola, mundo")
}

pub fn routes() -> Routes {
    Routes::new().prefix("home").add("/hello", get(hello))
}
```

Finally, register this new controller routes in `app.rs`:

```rust
src/
  controllers/
  models/
  ..
  app.rs   <---- look here
```

Add the following in `routes()`:

```rust
// in src/app.rs
#[async_trait]
impl Hooks for App {
    ..
    fn routes() -> AppRoutes {
        AppRoutes::with_default_routes()
            .add_route(controllers::guide::routes())
            .add_route(controllers::auth::routes())
            .add_route(controllers::home::routes()) // <--- add this
    }
```

That's it. Kill the server and bring it up again:

<!-- <snip id="starting-the-server-command" inject_from="yaml" template="sh"> -->
```sh
cargo loco start
```
<!-- </snip> -->

And hit `/home/hello`:

```sh
$ curl localhost:5150/home/hello
ola, mundo
```

You can take a look at all of your routes with:

```
$ cargo loco routes
  ..
  ..
[POST] /api/auth/login
[POST] /api/auth/register
[POST] /api/auth/reset
[POST] /api/auth/verify
[GET] /home/hello      <---- this is our new route!
  ..
  ..
$
```

<div class="infobox">
The <em>SaaS Starter</em> keeps routes under <code>/api</code> because it is client-side ready and we are using the <code>--api</code> option in scaffolding. <br/>
When using client-side routing like React Router, we want to separate backend routes from client routes: the browser will use <code>/home</code> but not <code>/api/home</code> which is the backend route, and you can call <code>/api/home</code> from the client with no worries. Nevertheless, the routes: <code>/_health</code> and <code>/_ping</code> are exceptions, they stay at the root.
</div>

## MVCã¨ã‚ãªãŸ

**å¾“æ¥ã®MVCï¼ˆModel-View-Controllerï¼‰ã¯ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—UIãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‹ã‚‰ç”Ÿã¾ã‚Œã¾ã—ãŸã€‚** ã—ã‹ã—ã€Webã‚µãƒ¼ãƒ“ã‚¹ã¸ã®é©ç”¨æ€§ã«ã‚ˆã‚Šæ€¥é€Ÿã«æ¡ç”¨ã•ã‚Œã¾ã—ãŸã€‚MVCã®é»„é‡‘æ™‚ä»£ã¯2010å¹´ä»£åˆé ­ã§ã€ãã®å¾Œå¤šãã®ä»–ã®ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‚„ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãŒç™»å ´ã—ã¾ã—ãŸã€‚

**MVCã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ç°¡ç´ åŒ–ã™ã‚‹ãŸã‚ã®éå¸¸ã«å¼·åŠ›ãªåŸå‰‡ã¨ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã‚ã‚Š**ã€Locoã‚‚ã“ã‚Œã«å¾“ã£ã¦ã„ã¾ã™ã€‚

Webã‚µãƒ¼ãƒ“ã‚¹ã‚„APIã¯HTMLã‚„UIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆã—ãªã„ãŸã‚_ãƒ“ãƒ¥ãƒ¼_ã®æ¦‚å¿µã‚’æŒãŸãªã„ã‚‚ã®ã®ã€**_å®‰å®šã—ãŸ_ã€_å®‰å…¨ãª_ã‚µãƒ¼ãƒ“ã‚¹ã‚„APIã«ã¯ç¢ºå®Ÿã«ãƒ“ãƒ¥ãƒ¼ã®æ¦‚å¿µãŒã‚ã‚‹**ã¨ç§ãŸã¡ã¯ä¸»å¼µã—ã¾ã™ -- ãã‚Œã¯ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã€ãã®å½¢çŠ¶ã€äº’æ›æ€§ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚

```
// a typical loco app contains all parts of MVC

src/
  controllers/
    users.rs
    mod.rs
  models/
    _entities/
      users.rs
      mod.rs
    users.rs
    mod.rs
  views/
    users.rs
    mod.rs
```

**This is an important _cognitive_ principle**. And the principle claims that you can only create safe, compatible API responses if you treat those as a separate, independently governed _thing_ -- hence the 'V' in MVC, in Loco.

<div class="infobox">
Models in Loco carry the same semantics as in Rails: <b>fat models, slim controllers</b>. This means that every time you want to build something -- <em>you reach out to a model</em>.
</div>

### ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆ

Locoã®ãƒ¢ãƒ‡ãƒ«ã¯ãƒ‡ãƒ¼ã‚¿*ã¨*æ©Ÿèƒ½ã‚’è¡¨ã—ã¾ã™ã€‚é€šå¸¸ã€ãƒ‡ãƒ¼ã‚¿ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ“ã‚¸ãƒã‚¹ãƒ—ãƒ­ã‚»ã‚¹ã®ã»ã¨ã‚“ã©ã€ã‚‚ã—ãã¯ã™ã¹ã¦ãŒãƒ¢ãƒ‡ãƒ«ï¼ˆActive Recordã¨ã—ã¦ï¼‰ã¾ãŸã¯è¤‡æ•°ã®ãƒ¢ãƒ‡ãƒ«ã®ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚

`Article`ã¨ã„ã†æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆã—ã¦ã¿ã¾ã—ã‚‡ã†ï¼š

```sh
$ cargo loco generate model article title:string content:text

added: "migration/src/m20231202_173012_articles.rs"
injected: "migration/src/lib.rs"
injected: "migration/src/lib.rs"
added: "tests/models/articles.rs"
injected: "tests/models/mod.rs"
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

**ã‚¹ã‚­ãƒ¼ãƒã®æ•´åˆæ€§ã‚’ä¿ã¤ã«ã¯ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¾ã™**ã€‚ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹é€ ã¸ã®å˜ä¸€ã®å¤‰æ›´ã§ã™ï¼šå®Œå…¨ãªãƒ†ãƒ¼ãƒ–ãƒ«è¿½åŠ ã€å¤‰æ›´ã€ã¾ãŸã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆã‚’å«ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚

```rust
// this was generated into `migrations/` from the command:
//
// $ cargo loco generate model article title:string content:text
//
// it is automatically applied by Loco's migrator framework.
// you can also apply it manually using the command:
//
// $ cargo loco db migrate
//
#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                table_auto_tz(Articles::Table)
                    .col(pk_auto(Articles::Id))
                    .col(string_null(Articles::Title))
                    .col(text(Articles::Content))
                    .to_owned(),
            )
            .await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(Articles::Table).to_owned())
            .await
    }
}
```

You can recreate a complete database **by applying migrations in-series onto a fresh database** -- this is done automatically by Loco's migrator (which is derived from SeaORM).

When generating a new model, Loco will:

- Generate a new "up" database migration
- Apply the migration
- Reflect the entities from database structure and generate back your `_entities` code

You will find your new model as an entity, synchronized from your database structure in `models/_entities/`:

```
src/models/
â”œâ”€â”€ _entities
â”‚Â Â  â”œâ”€â”€ articles.rs  <-- sync'd from db schema, do not edit
â”‚Â Â  â”œâ”€â”€ mod.rs
â”‚Â Â  â”œâ”€â”€ prelude.rs
â”‚Â Â  â””â”€â”€ users.rs
â”œâ”€â”€ articles.rs   <-- generated for you, your logic goes here.
â”œâ”€â”€ mod.rs
â””â”€â”€ users.rs
```

### Using `playground` to interact with the database

Your `examples/` folder contains:

- `playground.rs` - a place to try out and experiment with your models and app logic.

Let's fetch data using your models, using `playground.rs`:

```rust
// located in examples/playground.rs
// use this file to experiment with stuff
use loco_rs::{cli::playground, prelude::*};
// to refer to articles::ActiveModel, your imports should look like this:
use myapp::{app::App, models::_entities::articles};

#[tokio::main]
async fn main() -> loco_rs::Result<()> {
    let ctx = playground::<App>().await?;

    // add this:
    let res = articles::Entity::find().all(&ctx.db).await.unwrap();
    println!("{:?}", res);

    Ok(())
}

```

### Return a list of posts

In the example, we use the following to return a list:

```rust
let res = articles::Entity::find().all(&ctx.db).await.unwrap();
```

To see how to run more queries, go to the [SeaORM docs](https://www.sea-ql.org/SeaORM/docs/next/basic-crud/select/).

To execute your playground, run:

```rust
$ cargo playground
[]
```

Now, let's insert one item:

```rust
async fn main() -> loco_rs::Result<()> {
    let ctx = playground::<App>().await?;

    // add this:
    let active_model: articles::ActiveModel = articles::ActiveModel {
        title: Set(Some("how to build apps in 3 steps".to_string())),
        content: Set(Some("use Loco: https://loco.rs".to_string())),
        ..Default::default()
    };
    active_model.insert(&ctx.db).await.unwrap();

    let res = articles::Entity::find().all(&ctx.db).await.unwrap();
    println!("{:?}", res);

    Ok(())
}
```

And run the playground again:

```sh
$ cargo playground
[Model { created_at: ..., updated_at: ..., id: 1, title: Some("how to build apps in 3 steps"), content: Some("use Loco: https://loco.rs") }]
```

We're now ready to plug this into an `articles` controller. First, generate a new controller:

```sh
$ cargo loco generate controller articles --api
added: "src/controllers/articles.rs"
injected: "src/controllers/mod.rs"
injected: "src/app.rs"
added: "tests/requests/articles.rs"
injected: "tests/requests/mod.rs"
```

Edit `src/controllers/articles.rs`:

```rust
#![allow(clippy::unused_async)]
use loco_rs::prelude::*;

use crate::models::_entities::articles;

pub async fn list(State(ctx): State<AppContext>) -> Result<Response> {
    let res = articles::Entity::find().all(&ctx.db).await?;
    format::json(res)
}

pub fn routes() -> Routes {
    Routes::new().prefix("api/articles").add("/", get(list))
}
```

Now, start the app:

<!-- <snip id="starting-the-server-command" inject_from="yaml" template="sh"> -->
```sh
cargo loco start
```
<!-- </snip> -->

And make a request:

```sh
$ curl localhost:5150/api/articles
[{"created_at":"...","updated_at":"...","id":1,"title":"how to build apps in 3 steps","content":"use Loco: https://loco.rs"}]
```

## CRUD APIã®æ§‹ç¯‰

æ¬¡ã«ã€å˜ä¸€ã®è¨˜äº‹ã®å–å¾—ã€å‰Šé™¤ã€ç·¨é›†æ–¹æ³•ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚IDã«ã‚ˆã‚‹è¨˜äº‹ã®å–å¾—ã¯`axum`ã®`Path`ã‚¨ã‚¯ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦è¡Œã„ã¾ã™ã€‚

Replace the contents of `articles.rs` with this:

```rust
// this is src/controllers/articles.rs

#![allow(clippy::unused_async)]
use loco_rs::prelude::*;
use serde::{Deserialize, Serialize};

use crate::models::_entities::articles::{ActiveModel, Entity, Model};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Params {
    pub title: Option<String>,
    pub content: Option<String>,
}

impl Params {
    fn update(&self, item: &mut ActiveModel) {
        item.title = Set(self.title.clone());
        item.content = Set(self.content.clone());
    }
}

async fn load_item(ctx: &AppContext, id: i32) -> Result<Model> {
    let item = Entity::find_by_id(id).one(&ctx.db).await?;
    item.ok_or_else(|| Error::NotFound)
}

pub async fn list(State(ctx): State<AppContext>) -> Result<Response> {
    format::json(Entity::find().all(&ctx.db).await?)
}

pub async fn add(State(ctx): State<AppContext>, Json(params): Json<Params>) -> Result<Response> {
    let mut item: ActiveModel = Default::default();
    params.update(&mut item);
    let item = item.insert(&ctx.db).await?;
    format::json(item)
}

pub async fn update(
    Path(id): Path<i32>,
    State(ctx): State<AppContext>,
    Json(params): Json<Params>,
) -> Result<Response> {
    let item = load_item(&ctx, id).await?;
    let mut item = item.into_active_model();
    params.update(&mut item);
    let item = item.update(&ctx.db).await?;
    format::json(item)
}

pub async fn remove(Path(id): Path<i32>, State(ctx): State<AppContext>) -> Result<Response> {
    load_item(&ctx, id).await?.delete(&ctx.db).await?;
    format::empty()
}

pub async fn get_one(Path(id): Path<i32>, State(ctx): State<AppContext>) -> Result<Response> {
    format::json(load_item(&ctx, id).await?)
}

pub fn routes() -> Routes {
    Routes::new()
        .prefix("api/articles")
        .add("/", get(list))
        .add("/", post(add))
        .add("/{id}", get(get_one))
        .add("/{id}", delete(remove))
        .add("/{id}", patch(update))
}
```

A few items to note:

- `Params` is a strongly typed required params data holder, and is similar in concept to Rails' _strongparams_, just safer.
- `Path(id): Path<i32>` extracts the `:id` component from a URL.
- Order of extractors is important and follows `axum`'s documentation (parameters, state, body).
- It's always better to create a `load_item` helper function and use it in all singular-item routes.
- While `use loco_rs::prelude::*` brings in anything you need to build a controller, you should note to import `crate::models::_entities::articles::{ActiveModel, Entity, Model}` as well as `Serialize, Deserialize` for params.


<div class="infobox">
The order of the extractors is important, as changing the order of them can lead to compilation errors. Adding the <code>#[debug_handler]</code> macro to handlers can help by printing out better error messages. More information about extractors can be found in the <a href="https://docs.rs/axum/latest/axum/extract/index.html#the-order-of-extractors">axum documentation</a>.
</div>


You can now test that it works, start the app:

<!-- <snip id="starting-the-server-command" inject_from="yaml" template="sh"> -->
```sh
cargo loco start
```
<!-- </snip> -->

Add a new article:

```sh
$ curl -X POST -H "Content-Type: application/json" -d '{
  "title": "Your Title",
  "content": "Your Content xxx"
}' localhost:5150/api/articles
{"created_at":"...","updated_at":"...","id":2,"title":"Your Title","content":"Your Content xxx"}
```

Get a list:

```sh
$ curl localhost:5150/api/articles
[{"created_at":"...","updated_at":"...","id":1,"title":"how to build apps in 3 steps","content":"use Loco: https://loco.rs"},{"created_at":"...","updated_at":"...","id":2,"title":"Your Title","content":"Your Content xxx"}
```

### 2ã¤ç›®ã®ãƒ¢ãƒ‡ãƒ«ã®è¿½åŠ 

åˆ¥ã®ãƒ¢ãƒ‡ãƒ«ã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚ä»Šåº¦ã¯`Comment`ã§ã™ã€‚ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã—ãŸã„ã¨æ€ã„ã¾ã™ - ã‚³ãƒ¡ãƒ³ãƒˆã¯æŠ•ç¨¿ã«å±ã—ã€å„æŠ•ç¨¿ã¯è¤‡æ•°ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚

Instead of coding the model and controller by hand, we're going to create a **comment scaffold** which will generate a fully working CRUD API comments. We're also going to use the special `references` type:

```sh
$ cargo loco generate scaffold comment content:text article:references --api
```

<div class="infobox">
The special <code>&lt;other_model&gt;:references:&lt;column_name&gt;</code> is also available. For when you want to have a different name for your column.
</div>

If you peek into the new migration, you'll discover a new database relation in the articles table:

```rust
      ..
      ..
  .col(integer(Comments::ArticleId))
  .foreign_key(
      ForeignKey::create()
          .name("fk-comments-articles")
          .from(Comments::Table, Comments::ArticleId)
          .to(Articles::Table, Articles::Id)
          .on_delete(ForeignKeyAction::Cascade)
          .on_update(ForeignKeyAction::Cascade),
  )
      ..
      ..
```


Now, lets modify our API in the following way:

1. Comments can be added through a shallow route: `POST comments/`
2. Comments can only be fetched in a nested route (forces a Post to exist): `GET posts/1/comments`
3. Comments cannot be updated, fetched singular, or deleted

In `src/controllers/comments.rs`, remove unneeded routes and functions:

```rust
pub fn routes() -> Routes {
    Routes::new()
        .prefix("api/comments")
        .add("/", post(add))
        // .add("/", get(list))
        // .add("/{id}", get(get_one))
        // .add("/{id}", delete(remove))
        // .add("/{id}", patch(update))
}
```

Also adjust the Params & update functions in `src/controllers/comments.rs`, by updating the scaffolded code marked with `<- add this`

```rust
pub struct Params {
    pub content: Option<String>,
    pub article_id: i32, // <- add this
}

impl Params {
    fn update(&self, item: &mut ActiveModel) {
        item.content = Set(self.content.clone());
        item.article_id = Set(self.article_id.clone()); // <- add this
    }
}
```

Now we need to fetch a relation in `src/controllers/articles.rs`. Add the following route:

```rust
pub fn routes() -> Routes {
  // ..
  // ..
  .add("/{id}/comments", get(comments))
}
```

And implement the relation fetching:

```rust
// to refer to comments::Entity, your imports should look like this:
use crate::models::_entities::{
    articles::{ActiveModel, Entity, Model},
    comments,
};

pub async fn comments(
    Path(id): Path<i32>,
    State(ctx): State<AppContext>,
) -> Result<Response> {
    let item = load_item(&ctx, id).await?;
    let comments = item.find_related(comments::Entity).all(&ctx.db).await?;
    format::json(comments)
}
```

<div class="infobox">
This is called "lazy loading", where we fetch the item first and later its associated relation. Don't worry - there is also a way to eagerly load comments along with an article.
</div>

Now start the app again:

<!-- <snip id="starting-the-server-command" inject_from="yaml" template="sh"> -->
```sh
cargo loco start
```
<!-- </snip> -->

Add a comment to Article `1`:

```sh
$ curl -X POST -H "Content-Type: application/json" -d '{
  "content": "this rocks",
  "article_id": 1
}' localhost:5150/api/comments
{"created_at":"...","updated_at":"...","id":4,"content":"this rocks","article_id":1}
```

And, fetch the relation:

```sh
$ curl localhost:5150/api/articles/1/comments
[{"created_at":"...","updated_at":"...","id":4,"content":"this rocks","article_id":1}]
```

This ends our comprehensive _Guide to Loco_. If you made it this far, hurray!.

## ã‚¿ã‚¹ã‚¯ï¼šãƒ‡ãƒ¼ã‚¿ãƒ¬ãƒãƒ¼ãƒˆã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

å®Ÿä¸–ç•Œã®ã‚¢ãƒ—ãƒªã¯å®Ÿä¸–ç•Œã®çŠ¶æ³ã‚’å‡¦ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚„é¡§å®¢ãŒä½•ã‚‰ã‹ã®ãƒ¬ãƒãƒ¼ãƒˆã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

You can:

- Connect to your production database, issue ad-hoc SQL queries. Or use some kind of DB tool. _This is unsafe, insecure, prone to errors, and cannot be automated_.
- Export your data to something like Redshift, or Google, and issue a query there. _This is a waste of resource, insecure, cannot be tested properly, and slow_.
- Build an admin. _This is time-consuming, and waste_.
- **Or build an adhoc task in Rust, which is quick to write, type safe, guarded by the compiler, fast, environment-aware, testable, and secure.**

This is where `cargo loco task` comes in.

First, run `cargo loco task` to see current tasks:

```sh
$ cargo loco task
seed_data		[Task for seeding data]
```

Generate a new task `user_report`

```sh
$ cargo loco generate task user_report

added: "src/tasks/user_report.rs"
injected: "src/tasks/mod.rs"
injected: "src/app.rs"
added: "tests/tasks/user_report.rs"
injected: "tests/tasks/mod.rs"
```

In `src/tasks/user_report.rs` you'll see the task that was generated for you. Replace it with following:

```rust
// find it in `src/tasks/user_report.rs`

use loco_rs::prelude::*;
use loco_rs::task::Vars;

use crate::models::users;

pub struct UserReport;

#[async_trait]
impl Task for UserReport {
    fn task(&self) -> TaskInfo {
      // description that appears on the CLI
        TaskInfo {
            name: "user_report".to_string(),
            detail: "output a user report".to_string(),
        }
    }

    // variables through the CLI:
    // `$ cargo loco task name:foobar count:2`
    // will appear as {"name":"foobar", "count":2} in `vars`
    async fn run(&self, app_context: &AppContext, vars: &Vars) -> Result<()> {
        let users = users::Entity::find().all(&app_context.db).await?;
        println!("args: {vars:?}");
        println!("!!! user_report: listing users !!!");
        println!("------------------------");
        for user in &users {
            println!("user: {}", user.email);
        }
        println!("done: {} users", users.len());
        Ok(())
    }
}
```

You can modify this task as you see fit. Access the models with `app_context`, or any other environmental resources, and fetch
variables that were given through the CLI with `vars`.

Running this task is done with:

```rust
$ cargo loco task user_report var1:val1 var2:val2 ...

args: Vars { cli: {"var1": "val1", "var2": "val2"} }
!!! user_report: listing users !!!
------------------------
done: 0 users
```
If you have not added a user before, the report will be empty.

To add a user check out chapter [Registering a New User](/docs/getting-started/tour/#registering-a-new-user) of [A Quick Tour with Loco](/docs/getting-started/tour/).

Remember: this is environmental, so you write the task once, and then execute in development or production as you wish. Tasks are compiled into the main app binary.

## èªè¨¼ï¼šãƒªã‚¯ã‚¨ã‚¹ãƒˆã®èªè¨¼

`SaaS App`ã‚¹ã‚¿ãƒ¼ã‚¿ãƒ¼ã‚’é¸æŠã—ãŸå ´åˆã€å®Œå…¨ã«è¨­å®šã•ã‚ŒãŸèªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¢ãƒ—ãƒªã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã¯ãšã§ã™ã€‚
**ã‚³ãƒ¡ãƒ³ãƒˆã®è¿½åŠ **æ™‚ã«èªè¨¼ã‚’è¦æ±‚ã™ã‚‹æ–¹æ³•ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

Go back to `src/controllers/comments.rs` and take a look at the `add` function:

```rust
pub async fn add(State(ctx): State<AppContext>, Json(params): Json<Params>) -> Result<Response> {
    let mut item: ActiveModel = Default::default();
    params.update(&mut item);
    let item = item.insert(&ctx.db).await?;
    format::json(item)
}
```

To require authentication, we need to modify the function signature in this way:

```rust
async fn add(
    auth: auth::JWT,
    State(ctx): State<AppContext>,
    Json(params): Json<Params>,
) -> Result<Response> {
    // we only want to make sure it exists
    let _current_user = crate::models::users::Model::find_by_pid(&ctx.db, &auth.claims.pid).await?;

    // next, update
    // homework/bonus: make a comment _actually_ belong to user (user_id)
    let mut item: ActiveModel = Default::default();
    params.update(&mut item);
    let item = item.insert(&ctx.db).await?;
    format::json(item)
}
```
